= Лабораторная работа №1. Изучение принципов работы микропроцессорного ядра RISC-V.
Ибрагимов С. В.; Попов А. Ю.; Дубровин Е. Н.
:example-caption: Пример
:figure-caption: Рисунок
:source-highlighter: highlight
:sectnums:
:toc:
:toc-title: Содержание
:toclevels: 4

== Введение

== Цели работы
Основной целью работы является ознакомление с принципами функционирования,
построения и особенностями архитектуры суперскалярных конвейерных микропроцессоров.
Дополнительной целью работы является знакомство с принципами проектирования и
верификации сложных цифровых устройств с использованием языка описания аппаратуры
SystemVerilog и ПЛИС.

== Используемые средства
Для достижения поставленных целей в настоящей лабораторной работе
используется синтезируемое описание микропроцессорного ядра
Taiga (https://gitlab.com/sfu-rcl/Taiga, авторы - Eric Matthews,  Lesley Shannon),
реализующего систему команд RV32I семейства RISC-V. Данное описание выполнено
на языке описания аппаратуры SystemVerilog.

В ходе лабораторной работы используется средство моделирования MentorGraphics Modelsim для
моделирования работы исследуемого микропроцессора в процессе выполнения программы и
наблюдения формы внутренних сигналов.

== Архитектура набора команд RV32I

RISC-V является открытым современным набором команд, который может использоваться для
построения как микроконтроллеров, так и высокопроизводительных микропроцессоров.
В связи с такой широкой областью применения в систему команд введена вариативность.
Таким образом, термин RISC-V фактически является названием для семейства различных систем
команд, которые строятся вокруг базового набора команд, путем внесения в него различных расширений.

В данной работе исследуется набор команд RV32I, который включает в себя основные
команды 32-битной целочисленной арифметики кроме умножения и деления. В рамках
данного набора команд мы не будем рассматривать системные команды, связанные с
таймерами, системными регистрами, управлением привилегиями, прерываниями и исключениями.

В настоящем разделе описывается *архитектура набора команд*, то есть архитектура
абстрактной вычислительной машины с точки зрения набора команд без связи с
конкретной аппаратной реализацией.

=== Регистровая модель

Набор команд RV32I предполагает использование *32 регистров общего назначения x0-x31 размером в 32 бита каждый*
и регистр *pc*, хранящего адрес следующей команды. Все регистры общего назначения
равноправны, в любой команде могут использоваться любые из регистров. Регистр `pc`
не может использоваться в командах.

IMPORTANT: Регистр `x0` всегда содержит значение 0.
Запись в него не производит никакого эффекта.

NOTE: Существует соглашение, предполагающее
использование некоторых регистров для определенных целей (например, для передачи аргументов
при вызове функций или для возврата результата), однако, данное соглашение никак не связано с архитектурой
и потому не будет приниматься нами во внимание.

=== Модель памяти
Архитектура RV32I предполагает плоское линейное 32-х битное адресное пространство.
Минимальной адресуемой единицей информации является 1 байт. Используется порядок
байтов от младшего к старшему (Little Endian), то есть, младший байт 32-х битного слова
находится по младшему адресу (по смещению 0). Отсутствует разделение на адресные пространства
команд, данных и ввода-вывода. Распределение областей памяти между различными устройствами
(ОЗУ, ПЗУ, устройства ввода-вывода) определяется реализацией.

=== Система команд

Большая часть команд RV32I является трехадресными, выполняющими операции над
двумя заданными явно операндами, и сохраняющими результат в регистре.
Операндами могут являться регистры или константы, явно заданные в коде команды.
Операнды всех команд (кроме команды `auipc`) задаются явно. В том случае, если операндами
являются регистры, мы будем их называть *исходными регистрами (rs, source register)*,
регистр, в который сохраняется результат -- *целевым регистром (rd, destination register)*.

IMPORTANT: В отличие от большинства других архитектур в RISC-V не используется понятие флага,
вместо них используются команды условного перехода с использованием сравнения
регистров.

Архитектура RV32I, как и большая часть RISC-архитектур, предполагает разделение команд
на команды доступа к памяти (чтение данных из памяти в регистр или
запись данных из регистра в память) и команды обработки данных в регистрах.

Таким образом, команды RV32I можно разделить на следующие категории:

. Команды обработки данных

.. Арифметические и логические команды

.. Команды сравнения

.. Команды сдвига

.. Команды формирования значения в старшей части регистра

. Команды передачи управления

.. Команды безусловного перехода с сохранением адреса возврата

.. Команды условного перехода

. Команды доступа к памяти

.. Команды загрузки

.. Команды сохранения

. Системные команды

Команды в ассемблере RISC-V записываются с использованием следующего синтаксиса:

.Для команд обработки данных:

....
cmd rd, rs1, rs2
....
или
....
cmd rd, rs1, imm12
....
или
....
cmd rd, rs1, imm5
....

Где:

[horizontal]
`cmd`                :: Обозначение команды
`rd`                :: Целевой регистр;
`rs1`, `rs2`        :: Исходные регистры;
`imm12`, `imm5`     :: Соответственно 12-ти или 5-ти битная константа.

.Для команд доступа к памяти и команды перехода со смещением:

....
cmd rd, imm12(rs1)
....
или
....
cmd rs2, imm12(rs1)
....

Выражение `imm12(rs1)` обозначает `rs1+imm12`, то есть косвенное обращение к памяти
с формированием адреса из базового регистра `rs1` и константного смещения `imm12`.

Приведем теперь список некоторых команд RV32I. При описании команд будем использовать
псевдокод, использующий конструкцию `IF-THEN-ELSE`, арифметические и логические
операторы аналогично языку C (`+`,`-`, `>`, `<=`, `==`, `|`, `^`, `&` и т.д.) и
специальные конструкции, приведенные ниже.

[horizontal]
`(signed) value` :: Трактовать `value` как знаковое.

`(unsigned) value` :: Трактовать `value` как беззнаковое.

`:=`  :: Присваивание

`ZeroExtend (value)` :: Дополнить `value` нулями в старших разрядах до требуемого размера.

`SignExtend (value)` :: Дополнить `value` битами, значения которых равны значению старшего (знакового) разряда `value`, до требуемого размера. +
Например, 12-ти битное число 0x823 при дополнении до 32-х бит будет равно 0xFFFFF823.

`value[AA:BB]` :: Значение, образованное битами с BB (младший) по AA (старший) (включительно) `value`.

`MemReadNN(addr)` :: Инициировать транзакцию чтения `NN` бит (8, 16 или 32) по адресу `addr` на шине.

`MemWriteNN(addr, value)` :: Инициировать транзакцию записи `NN` бит (8, 16 или 32) со значением `value` по адресу `addr` на шине.

`GOTO (addr)`             :: Безусловный переход по адресу `addr`.

В таблице 1 приведено описание команд RV32I за исключением системных.
Исчерпывающее описание всех команд с комментариями, проясняющими соображения,
которыми пользовались разработчики RISC-V при проектировании набора команд, может быть найдено в [1].

Заметим, что некоторые команды являются псевдокомандами. Фактически, это удобные
сокращения для 1-2 других команд, которые часто встречаются на практике и поддерживаются
ассемблером RISC-V.

.Команды RV32I
[options="",cols="9,^.^15,21a"]
|=================================
|Команда | Описание | Псевдокод

3+^h| 1. Арифметико-логические команды

3+^h| 1.1 Арифметические команды

|`addi rd, rs1, imm12` 1.2+|Сложение (переполнение игнорируется)
|`rd := rs1 + SignExtend(imm12)`

|`ADD rd, rs1, rs2`
<a|`rd := rs1 + rs2`

|`SUB rd, rs1, rs2`   |Вычитание (переполнение игнорируется)
|`rd := rs1 - rs2`

|`MV   rd, rs1`        |Псевдоинструкция копирования. +
Кодируется как `ADDI rd, rs1, 0`
|`rd := rs1`

|`li   rd, imm12`        |Псевдоинструкция записи константы в rd. +
Кодируется как `ADDI rd, x0, imm12`
|`rd := SignExtend(imm12)`

|`NOP` |Псевдоинструкция пустой операции. +
Кодируется как `ADDI x0, x0, 0`.
|

3+^h| 1.3 Побитовые логические команды

|`ANDI rd, rs1, Imm12` |Побитовое И
|`rd := rs1 & SignExtend(Imm12)`

|`AND rd, rs1, rs2` |Побитовое И
|`rd := rs1 & rs2`

|`ORI rd, rs1, Imm12` |Побитовое ИЛИ
|`rd := rs1 or SignExtend(Imm12)`

|`OR rd, rs1, rs2` |Побитовое ИЛИ
|`rd := rs1 or rs2`

|`XORI rd, rs1, Imm12` |Побитовое XOR
|`rd := rs1 ^ SignExtend(Imm12)`

|`XOR rd, rs1, rs2` |Побитовое XOR
|`rd := rs1 ^ rs2`

|`NOT rd, rs1` |Псевдоинструкция побитового НЕ. +
Кодируется как `XORI rd, rs, -1`
|`rd := ~rs1`

3+^h| 1.4 Команды сдвига

|`SLLI rd, rs1, Imm5` 1.2+|Логический сдвиг влево. +
При сдвиге освобождающиеся разряды заполняются 0.
|`rd := rs1 << Imm5`

|`SLL rd, rs1, rs2`
<a|`rd := rs1 << ( rs2[4:0] )`


|`SRLI rd, rs1, Imm5` 1.2+|Логический сдвиг вправо. +
При сдвиге освобождающиеся разряды заполняются 0
|`rd := rs >> Imm5`

|`SRL rd, rs1, rs2`
<a|`rd := rs1 >> ( rs2[4:0] )`

|`SRAI rd, rs1, Imm5` 1.2+|Арифметический сдвиг вправо. +
При сдвиге освобождающиеся разряды заполняются значением знакового бита rs1.
|`rd := rs >> Imm5`

|`SRA rd, rs1, rs2`
<a|`rd := rs1 >> ( rs2[4:0] )`

3+^h| 1.2 Команды сравнения
|`SLTI rd, rs1, Imm12` 1.2+|Сравнение с учетом знака
|
....
IF(rs1 < SignExtend(Imm12)) then
    rd := 1
  else
    rd := 0
....

|`SLT rd, rs1, rs2`
<a|
....
IF(rs1 < rs2) then
    rd := 1
  else
    rd := 0
....


|`SLTIU rd, rs1, imm12` 1.2+|Сравнение без учета знака
|
....
IF(rs1 < ZeroExtend(imm12)) then
    rd := 1
  else
    rd := 0
....

|`SLTU rd, rs1, rs2`
<a|
....
IF(rs1 < rs2) then
    rd := 1
  else
    rd := 0
....

|`SEQZ rd, rs1` |Псевдоинструкция сравнения с 0. +
Кодируется как `SLTIU rd, rs, 1`
|
....
IF(rs1 == 0) then
    rd := 1
  else
    rd := 0
....

|`SNEZ rd, rs1` |Псевдоинструкция сравнения с 0. +
Кодируется как `SLTU rd, x0, rs`
|
....
IF( rs1 != 0 ) then
    rd := 1
  else
    rd := 0
....

3+^h| 1.5 Команды формирования значения в старшей части регистра
|`lui rd, Imm20`    |Записать константу в старшую часть регистра, при этом младшие 12 бит заполняются 0.
|
....
rd[31:12] := Imm20
rd[11:0] := 0
....

|`auipc rd, imm20`    |Записать в `rd` значение pc со смещением
|`rd := (imm20 << 12) + pc`

3+^h| 2. Команды передачи управления
3+^h| 2.1 Команды безусловного перехода с сохранением адреса возврата

|`jal rd, imm20` |Переход относительно pc со смещением
|
....
rd := pc + 4
goto(pc + SignExtend(imm20 << 1))
....

|`jalr rd, imm12(rs)` |Переход относительно rs со смещением. При этом младший бит адреса перехода устанавливается в 0.
|
....
rd := pc + 4
goto(rs + SignExtend(imm12))
....

3+^h| 2.2 Команды условного перехода

|`BEQ rs1, rs2, Imm12`| Переход, если rs1==rs2
|
....
IF (rs1 == rs2) then
    GOTO( pc + SignExtend(imm12) )
....

|`BNE rs1, rs2, Imm12`| Переход, если rs1!=rs2
|
....
IF (rs1 != rs2) then
    GOTO( pc + SignExtend(imm12) )
....

|`BLT rs1, rs2, imm12`| Переход, если rs1<rs2
|
....
IF ((signed) rs1 < (signed) rs2) then
    GOTO( pc + SignExtend(imm12) )
....

|`BLTU rs1, rs2, imm12`| Переход, если rs1<rs2
|
....
IF ((unsigned) rs1 < (unsigned) rs2) then
    GOTO( pc + SignExtend(imm12) )
....

|`BGE rs1, rs2, imm12`| Переход, если rs1>=rs2
|
....
IF ((signed) rs1 >= (signed) rs2) then
    GOTO( pc + SignExtend(imm12) )
....

|`BGEU rs1, rs2, imm12`| Переход, если rs1>=rs2
|
....
IF ((unsigned) rs1 >= (unsigned) rs2) then
    GOTO( pc + SignExtend(imm12) )
....

3+^h| 3. Команды доступа к памяти

|`LW rd, imm12(rs)` |Загрузка 32-х бит
|
....
addr := rs + SignExtend(imm12)
rd := MemRead32(addr)
....

|`LH rd, imm12(rs)` |Загрузка 16-х бит
|
....
addr := rs + SignExtend(imm12)
rd := SignExtend( MemRead16(addr) )
....

|`lhu rd, imm12(rs)` |Загрузка 16-х бит
|
....
addr := rs + SignExtend(imm12)
rd := ZeroExtend( MemRead16(addr) )
....

|`lb rd, imm12(rs)` |Загрузка 8-и бит
|
....
addr := rs + SignExtend(imm12)
rd := SignExtend( MemRead8(addr) )
....

|`lbu rd, imm12(rs)` |Загрузка 8-и бит
|
....
addr := rs + SignExtend(imm12)
rd := ZeroExtend( MemRead8(addr) )
....

|`sw rs2, imm12(rs1)` |Сохранение 32-х бит  |`MemWrite32(rs1 + SignExtend(imm12), rs2)`

|`sh rs2, imm12(rs1)` |Сохранение 16-и бит  |`MemWrite16(rs1 + SignExtend(imm12), rs2)`

|`sb rs2, imm12(rs1)` |Сохранение 8-и бит   |`MemWrite8(rs1 + SignExtend(imm12), rs2)`
|=================================

=== Пример программы
Рассмотрим пример небольшой программы для RV32I, которым мы будем пользоваться далее
для исследования процесса выполнения команд.

Данная программа выполняет суммирование значений элементов масcива слов и увеличивает
это значение на 1.

....
        .section .text <1>
        .globl _start; <2>
        len = 8 #Размер массива <3>
        enroll = 4 #Количество обрабатываемых элементов за одну итерацию
        elem_sz = 4 #Размер одного элемента массива
_start: <4>
        addi x20, x0, len/enroll <5>
        la x1, _x #<6>
loop:
        lw x2, 0(x1) #<7>
        add x31, x31, x2 <8>
        lw x2, 4(x1)
        add x31, x31, x2
        lw x2, 8(x1)
        add x31, x31, x2
        lw x2, 12(x1)
        add x31, x31, x2
        addi x1, x1, elem_sz*enroll <9>
        addi x20, x20, -1 <10>
        bne x20, x0, loop <11>
        addi x31, x31, 1
forever: j forever <12>

        .section .data <13>
_x:     .4byte 0x1 <14>
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x6
        .4byte 0x7
        .4byte 0x8
....
<1> -- Объявление секции `.text`, содержащей исполняемый код.
<2> -- Объявление символа `_start`, имеющего глобальную видимость. Символ `_start`
это специальный символ, обозначающий точку входа в программу.
<3> -- Объявление констант.
<4> -- Метка.
<5> -- Арифметические выражения над константами могут использоваться в командах
на месте непосредственного операнда.
<6> -- Загрузка в  `x1` адреса символа `_x` (то есть, начала массива).
<7> -- Загрузка в `x2` числа по адресу, содержащемуся в `x1` по смещению `0`.
<8> -- Добавление к  `x31` (который хранит результат) значения x2.
<9> -- Смещение указателя `x1`.
<10> -- Уменьшение счетчика цикла.
<11> -- Условный переход на метку `loop`.
<12> -- Бесконечный цикл.
<13> -- Объявление секции данных.
<14> -- Начало описания массива.

Можно сказать, что данная программа эквивалентна следующему псевдокоду на языке C.
....
#define len 8
#define enroll 4
#define elem_sz 4
int _x[]={1,2,3,4,5,6,7,8};
void _start() {
    int x20 = len/enroll;
    int *x1 = _x;

    do {
      int x2 = x1[0];
      x31 += x2;
      x2 = x1[1];
      x31 += x2;
      x2 = x1[2];
      x31 += x2;
      x2 = x1[3];
      x31 += x2;
      x1 += enroll;
      x20--;
    } while(x20 != 0);
    x31++;
    while(1){}
}
....

Если выполнить компиляцию и дизассемблирование данной программы, то получится следующий
результат.

NOTE: Заметим, что адреса и коды команд приведены в шестнадцатеричной системе счисления.

....
80000000 <_start>:
80000000:	00200a13          	addi	x20,x0,2
80000004:	00000097          	auipc	x1,0x0 <1>
80000008:	03c08093          	addi	x1,x1,60 # 80000040 <_x>

8000000c <loop>:
8000000c:	0000a103          	lw	x2,0(x1)
80000010:	002f8fb3          	add	x31,x31,x2
80000014:	0040a103          	lw	x2,4(x1)
80000018:	002f8fb3          	add	x31,x31,x2
8000001c:	0080a103          	lw	x2,8(x1)
80000020:	002f8fb3          	add	x31,x31,x2
80000024:	00c0a103          	lw	x2,12(x1)
80000028:	002f8fb3          	add	x31,x31,x2
8000002c:	01008093          	addi	x1,x1,16
80000030:	fffa0a13          	addi	x20,x20,-1
80000034:	fc0a1ce3          	bne	x20,x0,8000000c <loop>
80000038:	001f8f93          	addi	x31,x31,1

8000003c <forever>:
8000003c:	0000006f          	jal	x0,8000003c <forever>
....
<1> -- Видно, что команда `la x1, _x` превращается в 2 команды: `auipc` и `addi`.
Первая из них используется для формирования значения в старшей части регистра `x1`.
После её выполнения в `x1` запишется значение 0x80000004 (адрес команды `auipc`).
После выполнения команды `addi`, регистр `x1` станет равен `0x80000004 + 60 = 0x80000040`,
то есть адресу нулевого элемента массива `_x`.

=== Задание №1
==== Подготовительные операции
Приступая к выполнению практической части лабораторной работы необходимо
получить копию репозитория, содержащего все необходимые файлы. Для этого необходимо:

. Создать каталог для хранения файлов `C://User/<фамилия(латиницей)>/`.
*Имя каталога не должно содержать пробелов!*
. Открыть терминал в данном каталоге. Для этого в контекстном меню каталога
выбрать пункт `GIT Bash Here`.
. Получить копию репозитория, выполнив команду (терминал после выполнения команды
закрывать не нужно, знак `$` вводить не нужно).
+
....
$ git clone https://gitlab.com/sibragimov/riscv-lab.git
....

В результате в каталоге будет создан подкаталог `riscv-lab`, а в нем, в свою очередь,
следующие подкаталоги:

. `taiga`. Содержит проект Quartus и все исходные тексты на языке SystemVerilog.
. `src`. Содержит исходные тексты тестового примера программы и сборочные файлы.

==== Выполнение задания

В процесссе выполнения задания необходимо выполнить следующие действия:

. Ознакомиться с теоретической частью, внимательно изучить примеры.
. Перейти в подкаталог `src` командой `cd riscv-lab/src`.
. Выполнить сборку, запустив команду `make`. Убедиться, что был создан файл `test.hex`,
содержащий шестнадцатеричное представление программы, а в окне терминала отобразился
дизассемблерный листинг. Сравнить дизассемблерный листинг с тем, который приведен в примере.
. Создать новый файл, содержащий текст программы по индивидуальному варианту (см. <<variants>>). Поместить его
в каталог `src`. Текст программы сохранить в файле с расширением `.s`.
+
IMPORTANT: При выполнении данного пункта не изменяйте файл `test.s`, но поместите
текст программы по индивидуальному варианту в новый файл с другим именем.

. Изучить текст программы по индивидуальному варианту. Поместить в отчете псевдокод,
соответствующий данной программе.
. Анализируя исходный текст программы, ответьте на вопрос: какое значение должно
содержаться в регистре `x31` в конце выполнения программы?
. Изменить в `Makefile` строку `SRC=` так, чтобы ее содержимое соответствовало
имени файла с текстом программы без расширения `.s`.
. Выполнить компиляцию командой `make`. В процессе будет создан файл с расширением `.hex`,
хранящий содержимое памяти команд и данных, а в окне терминала отобразится дизассемблерный листинг,
который *необходимо поместить в отчет вместе с исходным текстом*.

== Микроархитектура
Теперь перейдем от рассмотрения абстрактной архитектуры системы команд
к рассмотрению микроархитектуры ядра Taiga.

Будем рассматривать систему, состоящую из
вычислительного ядра Taiga и локальной памяти, реализованной с помощью
блочной памяти ПЛИС. Данная память является статической, синхронной и двухпортовой.
Один и тот же блок памяти используется для реализации как *памяти команд (ПК)*,
так и *памяти данных (ПД)*. Таким образом команды и данные находятся в едином
адресном пространстве. Дешифратор адресов настроен таким образом, что
блок памяти ПЛИС отображается в адресное пространство RISC-V с адреса *0x80000000*,
как мы это видели из рассмотрения примера выше.

Благодаря двухпортовой организации имеется возможность чтения и записи одновременно
и команд и данных. Кроме того, блочная память ПЛИС имеет фиксированную задержку доступа
в 1 такт. Таким образом, в нашей системе не будут возникать задержки доступа к памяти,
в связи с чем отпадает необходимость в кеш-памяти.

Taiga является *конвейерным* микропроцессором с элементами суперскалярности. При
конвейерной организации микропроцессора различные команды одновременно проходят различные
стадии своей обработки. Конвейер Taiga насчитывает 4 стадии.
В скобках приведены сокращенные обозначения стадий.

. Выборка(F). Стадия, на которой команда извлекается из ПК. Выполняется в блоке выборки;
. Диспетчеризация (ID). Стадия, на которой происходит запись команды в очередь команд
для декодирования. Выполняется в блоке управления метаданными;
. Декодирование и планирование на выполнение (D). Стадия на которой происходит определение типа и
полей команды и определение вычислительного блока, способного ее исполнить. Выполняется
в блоке декодирования и планирования на выполнение;
. Выполнение (AL, M1..M3, в зависимости от исполнительного блока). Стадия, на которой команда передается в блок выполнения.

"Ширина" конвейера Taiga (то есть, количество команд, которые одновременно могут находиться
на одной и той же стадии конвейера) равна 1 для всех стадий, кроме стадии выполнения.
В лучшем случае, каждая стадия конвейера (кроме выполнения) выполняется за один такт.

В состав рассматриваемой конфигурации Taiga входит 3 блока выполнения команд:
Арифметико-логическое устройство (АЛУ), блок доступа к памяти (LSU) и блок ветвлений.
АЛУ и блок ветвлений выполняют команды за 1 такт, LSU -- минимум за 3. Таким образом,
возможна ситуация когда команда обращения к памяти выполняется одновременно с арифметической командой.

Ниже показана упрощенная и укрупненная структурная схема ядра Taiga.

[[taiga_pipeline]]
.Структурная схема ядра Taiga
image::img/taiga_pipeline.png[]

На рисунке показаны основные блоки, из которых состоит ядро Taiga: блоки, выполняющие
стадии работы конвейера, исполнительные блоки, память команд и данных.

Рассмотрим последовательно этапы работы вычислительного конвейера Taiga в том порядке,
в котором их проходит любая команда в процессе своего выполнения. Рассмотрение этапов работы
удобнее начать с выполнения первой команды после снятия сигнала общесистемного сброса `ext_reset`.

=== Выборка
*Первым этапом* выполнения любой команды является *выборка (fetch)* кода команды из ПК.
Данный этап осуществляется блоком выборки, описанным в файле `core/fetch.sv`.

. В то время, пока сигнал `ext_reset` находится в состоянии 1, в регистре
`pc` блока выборки устанавливается значение `0x80000000` (то есть, адрес первой команды после сброса).
Однако, `pc` не изменяется в то время пока установлены сигналы `ext_reset` и `gc_fetch_hold`
(сигнал глобальной блокировки выборки команд). Адрес, соответствующий значению `pc`,
выставляется на шину адреса (ША) памяти команд (ПК) (сигнал `/tb/uut/cpu/instruction_bram/addr`).
К моменту прихода первого фронта `clk` после снятия `gc_fetch_hold` на шине данных памяти команд
уже имеется код команды по адресу `0x80000000`.

. По фронту `clk` после снятия `gc_fetch_hold` происходят следующие действия:
.. Память команд выдает данные (то есть, код команды), прочитанные по адресу,
который был выставлен на ША в предыдущем такте (сигнал `/tb/uut/cpu/instruction_bram/data_out`).
.. Блок выборки выдает эти данные на линию `fetch_instruction` (этот сигнал комбинационно связан с ШД памяти команд).
.. Устанавливается сигнал `fetch_complete`, подтверждающий выборку и наличие кода команды на линии `fetch_instruction`.
.. В `pc` записывается адрес следующей команды.
.. Этот адрес выставляется на ША памяти команд (сигнал на ША памяти команд формируется из `pc` комбинационно).

Как видно, этап выборки занимает 1 такт, что определяется принципом работы
синхронной памяти команд, а именно, что данные появляются на ШД в следующем такте,
после выставления адреса на ША.

NOTE: В случае выполнения программы из внешней памяти, длительность данного этапа увеличивается.
Для обеспечения работы блока выборки в условиях вообще говоря неизвестной заранее задержки доступа к памяти команд
в состав блока введен FIFO буфер, в который помещается информация о запросах к памяти команд. При выполнении очередного запроса
информация о нем извлекается из буфера, данные выставляются на линию `fetch_instruction`, что индицируется высоким уровнем сигнала
`fetch_complete`. Мы рассматриваем работу системы с памятью команд с фиксированной задержкой в 1 такт, поэтому подробное рассмотрение этих
процессов не входит в наши задачи.

Обратим внимание, что потребителем для блока выборки является блок управления метаданными (о нем -- чуть ниже).
Данный блок имеет возможность приостановить выборку в том случае, если не имеет
возможности обработать очередную выбранную команду. Для этого используется сигнал
`/tb/uut/cpu/id_block/pc_id_available`. В случае, если этот сигнал равен 0,
то сигнал `fetch_complete` в следующем такте не выставляется, несмотря на готовность данных,
и не формируется следующий адрес для выборки.

.Признак завершения выборки в текущем такте
IMPORTANT: Если в текущем такте сигнал `fetch_complete` установлен в 1, то в *предыдущем такте*
произошла выборка команды, идентификатор которой равен значению сигнала `pc_id` (данный сигнал
содержит идентификатор команды на этапе выборки) в *предыдущем такте*,
адрес -- значению сигнала `pc` в *предыдущем такте*, а код команды -- значению сигнала
`fetch_instruction` в *данном такте*.

=== Диспетчеризация
Блок выборки способен (при соблюдении ряда условий) осуществлять выборку 1 новой
команды каждый такт. Однако, как мы увидим ниже, блок декодирования совмещен с
блоком планирования команд на выполнение.
Не во всех случаях возможно планирование на исполнение 1 новой инструкции
каждый такт. Для согласование скоростей работы этих двух блоков между ними
имеется очередь выбранных команд, готовых для передачи в блок декодирования.

Постановка выбранной команды в данную очередь сопровождается присвоением ей
идентификатора `id`, который будет неизменен в процессе исполнения данной команды
и может использоваться для отслеживания процесса исполнения. Идентификатор представляет
собой число, максимальное значение которого (8) выбрано таким образом, чтобы
избежать попадания на конвейер двух команд с одинаковым идентификатором. В том случае,
если к моменту выборки очередной команды выясняется, что свободных идентификаторов нет,
то выборка команд приостанавливается до завершения выполнения одной из команд,
запланированных для выполнения. Для индикации этой ситуации используется сигнал
`/tb/uut/cpu/id_block/pc_id_available`.
Идентификатор следующей выбираемой команды получается из идентификатора предыдущей
увеличением на 1 с учетом проверки на достижение максимального значения.
Данная операция осуществляется в блоке управления метаинформацией
`core/instruction_metadata_and_id_management.sv`.

Данный этап осуществляется следующим образом:

. По фронту `clk`, завершающему такт, в течение которого осуществлялась выборка
очередной команды, ее адрес (то есть, значение регистра `pc` на момент выборки)
записывается в таблицу `pc_table` по присвоенному идентификатору. Идентификатор, который
присвоен команде в этом момент содержится в сигнале `/tb/uut/cpu/id_block/pc_id`.
Заметим, что идентификатор команды присваивается в момент начала выборки,
одновременно с выставлением адреса команды на ША памяти команд.
Идентификатор, который будет присвоен следующей команде увеличивается на 1.

. По следующему фронту `clk` (то есть, когда выборка произведена и установлен
сигнал `fetch_complete`) код команды записывается в таблицу `instruction_table`
по идентификатору, который был присвоен ранее. Одновременно с этим в
таблицу `rd_addr_table` записывается номер целевого регистра команды,
то есть выполняется первый этап декодирования команды.

На выходе блока управления метаинформацией формируется пакет данных, описывающих
очередную инструкцию для декодирования. Данный пакет (сигнал `/tb/uut/cpu/id_block/decode`)
формируется комбинационно из идентификатора очередной команды, которая еще не была
декодирована, ее адреса (`pc`), кода команды и флага `value`, означающего
сформированность пакета. Данный пакет подается на вход блока декодирования и
планирования на выполнение.

Видно, что этап диспетчеризации занимает 2 такта, однако первая его
часть осуществляется параллельно с выборкой. Окончательно имеем задержку в 1
такт после завершения выборки.

Заметим, что блок управления метаинформацией обрабатывает за 1 такт любую команду,
которая была выбрана на предыдущем такте. Это так потому, что в случае неготовности
блока управления метаинформацией сбрасывается сигнал `/tb/uut/cpu/id_block/pc_id_available`
и выборка не происходит. Таким образом получим:

.Признак завершения диспетчеризации в текущем такте
IMPORTANT: Если в текущем такте сигнал `fetch_complete` установлен в 1, то в *этом такте*
произошла диспетчеризация команды, идентификатор которой равен значению сигнала `pc_id` в *предыдущем такте*,
адрес -- значению сигнала `if_pc` в *предыдущем такте*, а код команды -- значению сигнала
`fetch_instruction` в *данном такте*.


==== Пример выполнения операций выборки и диспетчеризации
Рассмотрим временную диаграмму, поясняющую рассмотренные этапы выборки и диспетчеризации
(см. рисунок <<f_id>>). На данной диаграмме приведены сигналы, формируемые в модели в процессе
выполнения тестовой программы, рассмотренной выше. Заметим, что на диаграмме имеется сигнал
`/tb/cyc_cnt`. Данный сигнал формируется в тестбенче (то есть, это виртуальный сигнал,
отсутствующий в реальной аппаратуре) и используется для облегчения подсчета тактов.
`cyc_cnt` становится равным 1 в момент снятия сигналов `ext_reset`
и `gc_fetch_hold` и увеличивается на 1 по каждому следующему фронту `clk`.

[[f_id]]
.Пример выполнения операций выборки и диспетчеризации
image::img/f_id.png[]

Начнем рассмотрение диаграммы с такта 1 (здесь и далее будем отсчитывать такты
в соответствии с сигналом cyc_cnt). В начале такта снимается сигнал
`gc_fetch_hold` разрешая работу блока выборки, а сигнал `pc_id_available` равен 1,
что подтверждает готовность блока управления метаданными принять результат выборки.
`pc=0x80000000`. Адрес, соответствующий данному значению, а именно `0x20000000`
выставляется на ША (сигнал `addr`).

NOTE: Заметим, что память адресуется в RISC-V в байтах, а память команд адресуется
блоками по 4 байта. Таким образом, адрес на ША памяти команд получается из
адреса RISC-V (например, из `pc`) путем урезания 2-х младших бит (или деления на 4).

Выставление сигнала `en` разрешает работу памяти команд. Одновременно с этим
выставляется сигнал `pc_id_assigned`, указывающий блоку управления метаинформацией, что
запрос в память отправлен, и информация о текущем `pc` должна быть записана в очередь команд.
Текущее значение `pc` выдается в блоку управления метаинформацией через сигнал `if_pc`.
В начале следующего такта это значение (80000000) будет записано в `pc_table` по
индексу, равному значению текущего первого свободного id (в нашем случае 0), а
`pc_id` увеличится на 1. Это означает, что команде, которая будет выбрана по  адресу
80000000, присвоен `id=0`

В следующем такте (то есть, такте 2) данные по адресу `80000000`
(в нашем случае это 00200a13) выставляются памятью
команда (сигнал `data_out`). Эти данные выдаются из блока выборки
(сигнал `fetch_instruction`),
при этом сигнал `fetch_complete` равен 1.
Операция выборки данной команды завершается в такте 1, однако значение данных подается
на вход блока управления метаинформацией только в такте 2.

По фронту, завершающему такт 2, выбраный код команды (то есть, сигнал `fetch_instruction`) записывается
в таблицу `instruction_table` по индексу 0. Это завершает операцию диспетчеризации.

В начале такта 3 пакет данных для декодирования (сигнал `decode`, поле `valid` равно 1)
выдается в блок декодирования. Этим начинается этап декодирования и планирования для выполнения.

Таким образом, мы увидели, что команда по адресу `80000000` была выбрана в такте 1,
и прошла стадию диспетчеризации в такте 2.

Отложим по горизонтали такты, а по вертикали -- адреса, коды команд и ассемблерные коды команд, взятые из
дизассемблерный листинга (см. выше).
Обозначим такты, в которых команда проходила этап выборки символом F,
этап диспетчеризации -- символом ID.
Тогда, продолжая наши рассуждения по приведенной диаграмме получим следующую *трассу выполнения команды*:

[cols="8*m"]
|======================
.2+|Адрес (hex)    .2+|Код команды (hex) .2+|Команда .2+|id  4+|Такты
                                            |1  |2  |3  |4
|80000000       |00200a13  |addi x20,x0,2   |0     |F  |ID |   |
|80000004       |00000097  |auipc x1,0x0    |1     |   |F  |ID |
|80000008       |03c08093  |addi x1,x1,60   |2     |   |   |F  |ID
|8000000c       |????????  |                |3     |   |   |   |F
|======================

Где:

[horizontal]
F :: Такт, в котором происходит операция выборки;
ID :: Такт, в котором происходит операция диспетчеризации.

Вопросительные знаки в последней строке приведены потому, что на диаграмме мы не
можем видеть результаты выборки, которые будут видны только в такте 5, однако
видим `id`, который был присвоен команде, и адрес, по которому произведена выборка.

==== Задание №2
В ходе выполнения данного задания необходимо выполнить следующие действия:

. Запустить симуляцию в среде Modelsim. Для этого найти в каталоге `taiga` файл `run.sh` (если лабораторная 
работа выполняетсяв среде ОС Linux) или `run.bat` (для ОС Windows) и запустить его двойным щелчком мыши.
+
IMPORTANT: Обратите внимание, что в заданиях 2-4 (включительно) используется тестовая программа `test.s`, работа с 
индивидуальной программой начнется только с задания 5. 

. Запустить симуляцию, набрав в командной строке Modelsim команду `run 460us`.
. Изучить список сигналов, приведенных в окне Wave.
. В соответствии с таблицей, приведенной ниже, получить снимок экрана, содержащий
временную диаграмму выполнения стадий выборки и диспетчеризации команды с
указанным адресом. Для команд, входящих в тело цикла, приведен номер итерации.

[cols="10*m"]
|======================================
|Вариант                        |1             |2             |3
|4              |5              |6              |7             |8             |9

|Адрес команды, номер итерации  |8000000c, 1-я |80000010, 1-я |80000014, 1-я
|80000018, 1-я  |8000001c, 1-я  |80000020, 1-я  |80000024, 1-я |80000028, 1-я |8000002с, 1-я
|Вариант                        |10            |11            |12
|13             |14             |15             |16            |17            |18

|Адрес команды, номер итерации  |80000030, 1-я |80000034, 1-я |80000010, 2-я
|80000010, 2-я  |80000014, 2-я  |80000018, 2-я  |8000001с, 2-я |80000020, 2-я |80000024, 2-я
|Вариант                        |19            |20            |21
|22             |23             |--             |--            |--            |--

|Адрес команды, номер итерации  |80000028, 2-я |8000002с, 2-я |80000030, 2-я
|80000034, 2-я  |80000038, 2-я  |--             |--            |--            |--
|======================================


=== Декодирование и планирование на выполнение

После того, как на выходе блока управления метаинформацией сформирован пакет данных,
описывающих очередную инструкцию (то есть, поле `decode.valid` принимает значение 1) начинается этап
декодирования этой инструкции и планирования ее на выполнение. Данный этап
выполняется блоком декодирования и планирования на выполнение (описан в файле `core/decode_and_issue.sv`,
иерархическое имя экземпляра `/tb/uut/cpu/decode_and_issue_block`).

В ходе декодирования происходит анализ кода команды и определяются следующие характеристики команды:

- код операции (опкод);
- исполнительный блок, выполняющий команды данного типа;
- исходный регистр/регистры;
- регистр назначения команды (если есть);
- характеристики, специфичные для команд различных типов (например, выполняет
  ли команда обращения к памяти чтение или запись в память, вид арифметической операции (сложение, вычитание и т.д.)).

Декодирование является полностью комбинационной операцией и выполняется в течение
такта, который начинается в момент выставления сигнала `decode`. В том случае, если
имеется готовность потребного для выполнения команды исполнительного блока и предыдущая
команда не находится в состоянии конфликта (о конфликтах на конвеерее - ниже),
то инструкция планируется для выполнения. То есть,
сформированные управляющие сигналы для исполнительных блоков записываются в
выходные регистры блока декодирования.
Отметим, что в процессе декодирования формируется комбинационный сигнал `decode_advance`,
указывающий на то, что в момент прихода фронта `clk` произойдет планирование команды
на выполнение. Данный сигнал является входным для блока управления метаинформацией,
и предназначен для извлечения очередной команды из очереди команд, выбранных из памяти.

Отсюда видно, что в лучшем случае операция декодирования занимает 1 такт. Столько же
составляет задержка сигнала `issue` относительно сигнала `decode`. Однако,
в случае неготовности исполнительного блока или невозможности выполнить предыдущую
команду из-за конфликта в процессе декодирования могут возникнуть один или несколько
тактов ожидания. Во время ожидания сигнал `decode_advance` снят, следующая команда не извлекается
из очереди команд блока управления метаинформацией, выходные регистры блока декодирования не изменяют
своего значения. Таким образом, в лучшем случае возможно планирование на исполнение
*1 команды за 1 такт*.

В ходе декодирования формируются следующие сигналы для исполнительных блоков (имена
сигналов даны относительно иерархического имени блока декодирования):

- `issue`. Данный сигнал формируется для всех сигналов и описывает общие
характеристики команды. Данный сигнал является входным для блока управления метаинформацией и для
блока регистров. В блоке управления метаинформацией данный сигнал используется для
фиксации факта планирования на выполнение инструкции с данным `id`. Блок регистров
выдает значения исходных регистров команды, номера которых (регистров) указаны в полях
`issue.rs_addr[i], i=1,2`;
- Управляющие сигналы для конкретного исполнительного блока. Данный сигнал
имеет несколько полей, перечислим некоторые из них:
+
[horizontal]
`unit_issue[i]/new_request`:: Признак новой запланированной для данного блока команды;
`unit_issue[i]/id`:: Идентификатор команды;
`unit_issue[i]/ready`:: Готовность исполнительного блока.
- Сигнал, описывающий характеристики команды, специфичные для данного исполнительного
блока. Для каждого исполнительного блока имеется отдельный сигнал со специфическим набором полей.
Имена сигналов для АЛУ, Блока обращения к памяти и Блока ветвлений -- соответственно
`alu_inputs`, `ls_inputs`, `branch_inputs`.

После выдачи сигнала issue, содержащего среди прочего информацию об используемых
командой регистрах происходит проверка на наличие *конфликта* по регистрам.
Конфликт возникает в том случае, когда ранее была запланирована для выполнения, но еще не выполнена команда,
пишущая в тот регистр, который потребен текущей в качестве операнда. Данная проверка выполняется
в блоке управления метаинформацией, который на основании сигнала `issue` блока декодирования
формирует комбинационные сигналы, используемые в блоке декодирования для формирования комбинационных сигналов
`rs1_conflict` и `rs2_conflict`.

NOTE: Конкретный механизм формирования исходных сигналов для получения сигналов `rsX_conflict`
достаточно сложен, относится к техническим особенностям реализации конкретного вычислительного ядра
и потому выходит за рамки нашего рассмотрения.

Если конфликта нет (то есть, оба сигнала равны 0),
то формируется комбинационный сигнал `unit_issue[i]/new_request` (где i=1,2,3 - номер исполнительного блока),
индицирующий возможность выполнения команды.

Если конфликт есть, то сигнал `new_request` не будет
сформирован, а команда не будет принята для исполнения. В результате этого блок
декодирования будет находится в состоянии ожидания исполнения команды, вызвавшей
конфликт. Во время такого ожидания, как было указано выше, сигнал `decode_advance`
снят и новые команды не извлекаются из очереди блока управления метаинформацией.
После выполнения команды с конфликтом, сигнал, указывающий на наличие конфликта,
будет снят, сформируется сигнал `new_request` и текущая команды будет
принята исполнительным блоком.

[IMPORTANT]
====
.Признак завершения декодирования в текущем такте
Если в текущем такте сигнал `issue.stage_valid` равен 1, то возможны два случая:

. Если один из сигналов `unit_issue[i].new_request, i=1..3` равен 1, то
в прошлом такте завершено декодирование команды, `id` которой равен `issue.id`,
а в текущем такте она передана на выполнение;

. Если все сигналы `unit_issue[i].new_request, i=1..3` равны 0, а хотя бы один из сигналов
`rs1_conflict` или `rs2_conflict` равен 1, то в текущем такте команда, `id` которой равен `issue.id`,
находится в состоянии конфликта, а команда, `id` которой равен `decode.id`, ожидает
освобождения блока декодирования.
====

==== Пример выполнения операции декодирования

[[d]]
.Пример выполнения операции декодирования
image::img/d.png[]

В такте 2 происходит диспетчеризация команды с `id=0` и в такте 3 она поступает
на вход блока декодирования (это видно по тому признаку, что сигнал `decode.valid` установлен).

В такте 3 происходит декодирование команды. Так как в настоящее время не выполняется ни одной
команды, то команда точно может быть запланирована на выполнение. Поэтому устанавливается сигнал `decode_advance`
для передачи блоку управления метаинформацией указания выдать очередную команду для декодирования в следующем такте.

В начале такта 4 выдаются сигналы для исполнительных блоков: `issue`, `alu_inputs`
(так как эта команда выполняется АЛУ) и `unit_issue[0]`. На основании сигнала `issue`
формируются сигналы `rs1_conflict`, `rs2_conflict` равные 0, так как конфликта
по регистрам нет. Отсутствие конфликта дает возможность точно выполнить данную команду
в этом такте, соответственно сигнал `decode_advance` должен быть установлен в 1.

В следующем такте для декодирования выдается следующая команда и так далее. Занесем
эти сведения в трассу выполнения программы. На фрагменте трассы, приведенном ниже
знаком '*' обозначены те моменты времени, которые не видны ни на текущей, ни на прошлой диаграмме.

[cols="3*4m, 7*1m"]
|======================
.2+|Адрес (hex)   .2+|Код команды (hex) .2+|Команда .2+|id  6+|Такты
                                                   |1  |2  |3  |4  |5  |6
|80000000       |00200a13  |addi x20,x0,2   |0     |F  |ID |*D*|   |   |
|80000004       |00000097  |auipc x1,0x0    |1     |   |F  |ID |*D*|   |
|80000008       |03c08093  |addi x1,x1,60   |2     |   |   |F  |ID |*D*|
|8000000c       |0000a103  |lw x2,0(x1)     |3     |   |   |   |F  |ID*|*D*
|======================

Где:
[horizontal]
F :: Такт, в котором происходит операция выборки;
ID :: Такт, в котором происходит операция диспетчеризации;
D  :: Такт, в котором происходит операция декодирования.

==== Пример возникновения конфликта при планировании на выполнение
[[d_conflict]]
.Пример возникновения конфликта при планировании на выполнение
image::img/d_conflict.png[]

В такте 7 происходит декодирование команды с `id=4`, в такте 8 она планируется для
выполнения. В такте 8 обнаруживается конфликт по регистру `rs2`. Дело в том, что второй операнд
данной команды (`x2`) является целевым регистром предыдущей команды (`lw x2,0(x1)`),
выполнение которой еще не завершилось. Таким образом, команда не может быть принята
для исполнения в этом такте, что подтверждается снятием сигнала `unit_issue[1].new_request`.
Сигнал `decode_advance` также снимается, запрещая выдачу очередной команды в следующем такте.
На входе блока декодирования будет находится очередная команда, но она не будет
обработана до тех пор, пока текущая команда не будет передана для выполнения.

В такте 9 завершается выполнение предыдущей команды, в такте 10 сигнал `rs2_conflict` снимается.
В результате устанавливаются сигналы `unit_issue[1].new_request` и `decode_advance`.
Таким образом, в такте 10 произойдет декодирование команды с `id=5`.

Занесем эти сведения в трассу выполнения программы. На фрагменте трассы, приведенном ниже
знаком '*' обозначены те моменты времени, которые не видны ни на текущей, ни на прошлых диаграммах.

[cols="3*4m, 11*1m"]
|======================
.2+|Адрес (hex)   .2+|Код команды (hex) .2+|Команда .2+|id  10+|Такты
                                                      |1  |2  |3  |4  |5  |6  |7  |8   |9   |10
|80000000       |00200a13  |addi x20,x0,2      |0     |F  |ID |D  |   |   |   |   |    |    |
|80000004       |00000097  |auipc x1,0x0      |1      |   |F  |ID |D  |   |   |   |    |    |
|80000008       |03c08093  |addi x1,x1,60      |2     |   |   |F  |ID |D  |   |   |    |    |
|8000000c       |0000a103  |lw x2,0(x1)      |3       |   |   |   |F  |ID*|D  |   |    |    |
|80000010       |002f8fb3  |add x31,x31,x2      |4    |   |   |   |   |F* |ID*|*D*|*C* |*C* |
|80000014       |0040a103  |lw x2,4(x1)      |5       |   |   |   |   |   |F* |ID*|*W* |*W* |*D*
|======================

Где:
[horizontal]
F :: Такт, в котором происходит операция выборки;
ID :: Такт, в котором происходит операция диспетчеризации;
D  :: Такт, в котором происходит операция декодирования;
С  :: Такт, в котором команда не выполняется из-за конфликта;
W   :: Такт, в котором не происходит декодирования команды из-за загрузки блока декодирования.

==== Задание №3

В соответствии с таблицей, приведенной ниже, получить снимок экрана, содержащий
временную диаграмму выполнения стадии декодирования и планирования на выполнение
команды с указанным адресом. Для команд, входящих в тело цикла, приведен номер итерации.

[cols="10*m"]
|======================================
|Вариант                        |1             |2              |3             |4              |5              |6              |7             |8             |9
|Адрес команды, номер итерации  |80000018, 1-я |8000001c, 1-я  |80000020, 1-я |80000024, 1-я  |80000028, 1-я |8000002с, 1-я   |80000030, 1-я |80000034, 1-я |8000000с, 2-я
|Вариант                        |10            |11             |12            |13             |14             |15             |16            |17            |18
|Адрес команды, номер итерации  |80000010, 2-я |80000014, 2-я  |80000018, 2-я |8000001с, 2-я  |80000020, 2-я  |80000024, 2-я  |80000028, 2-я |8000002с, 2-я |80000030, 2-я
|Вариант                        |19            |20             |21            |22             |23             |24             |25            |26            |27
|Адрес команды, номер итерации  |80000034, 2-я |80000038, 2-я  |См. вариант 1 |См. вариант 2  |См. вариант 3  |См. вариант 4  |См. вариант 5 |См. вариант 6 |См. вариант 7
|======================================



=== Выполнение

После того, как команда запланирована для выполнения и нет конфликта по регистрам,
начинается этап выполнения команды каким-либо исполнительным блоком. Однако,
в начале этапа выполнения происходит чтение исходных регистров команды, информация
о которых содержится в сигнале `/tb/uut/cpu/decode_and_issue_block/issue`.
Чтение регистрового файла выполняется комбинационно, то есть, данные на выходе регистрового
файла выдаются в том же такте, что и сигнал `issue`.

NOTE: Регистровый файл Taiga устроен достаточно сложно и нетривиально. Рассмотрение
технических тонкостей реализации отдельных блоков не входит в наши задачи.
Поэтому для избежания затуманивания временной диаграммы, в тестбенче формируется сигнал с
содержимым регистрового файла в удобном для чтения виде на основании реальных сигналов регистрового файла.

В том случае, если исполнение команды занимает 1 такт, то запись в регистр назначения
происходит по фронту `clk`, завершающему такт. Таким образом, минимальная длительность
выполнения команды -- 1 такт.

NOTE: Мы рассматриваем конфигурацию в которой количество портов записи регистрового файла
равно количеству исполнительных блоков, записывающих результат в регистр (АЛУ и блок
обращения к памяти). В такой конфигурации всегда возможна запись результата в регистр
в том такте, когда завершилось выполнение команды. Если количество портов записи
регистров го файла меньше, чем количество блоков, записывающих результат, то могла
бы возникнуть ситуация, когда несколько команд завершает выполнение, но результаты
только части команд записываются в текущем такте. Результаты оставшихся команд
записываются в следующем такте.

Регистровый файл имеет специальный интерфейс для приема данных от исполнительных блоков для
записи результатов выполнения команд в регистры. Для каждого исполнительного блока
имеется свой набор сигналов -- `unit_wb[0]` для АЛУ и `unit_wb[1]` для блока
доступа к памяти. Среди сигналов данного интерфейса рассмотрим следующие:

- `unit_wb[i].done` - флаг готовности результата (то есть, флаг того, что дальнейшие
сигналы валидны);
- `unit_wb[i].id` - идентификатор завершенной команды;
- `unit_wb[i].rd` - значение результата.

IMPORTANT: Для блока АЛУ признаком, служащим для подтверждения готовности результата
является сочетание сигналов `unit_wb[0].done` и `unit_issue[0]/new_request`. Для
блока доступа к памяти - достаточно сигнала `unit_wb[1].done`.

Интересно, что номер регистра для записи не получается от исполнительного блока,
но получается блоком регистрового файла от блока управления метаинформацией
по идентификатору завершенной команды. Данная операция выполняется комбинационно.

==== АЛУ

АЛУ предназначено для выполнения команд обработки данных. В Taiga АЛУ выполняет
команды всегда за 1 такт и полностью комбинационно, по этой причине данный блок не может находится в состоянии неготовности.

АЛУ принимает на вход среди прочих сигнал `alu_inputs`, содержащий операнды (значения регистров
или константы, выделенные из кода команды), тип выполняемой операции и др. параметры.

Сигналы `done` и `id` комбинационно повторяют сигналы `new_request` и `id`, переданные в блок.

Таким образом, во время этапа выполнения команды АЛУ выполняются следующие действия:

. Блок декодирования формирует сигналы `issue`, `unit_issue[0]` и `alu_inputs`;
. В блоке управления метаинформацией формируются сигналы об использовании регистров,
являющихся операндами декодированной команды;
. В блоке декодирования вырабатываются сигналы `rs1_conflict` и `rs2_conflict`;
. Если конфликта нет, выставляется сигнал `unit_issue[0].new_request`;
. Регистровый файл выдает содержимое исходных регистров команды;
. АЛУ выполняет требуемую операцию и выдает результат в регистровый файл через сигнал `unit_wb[0].rd`,
одновременно выдавая сигналы `unit_wb[0].done` и `unit_wb[0].id`;
. Блок управления метаинформацией выдает номер регистра назначения команды,
идентификатор которой содержится в `unit_wb[0].id`;
. По фронту `clk` происходит запись в регистровый файл.

Все вышеперечисленные действия происходят комбинационно в течение одного такта.

.Признак завершения выполнения команды АЛУ в текущем такте
IMPORTANT: Если в текущем такте сигналы `unit_wb[0].done`
и `unit_issue[0]/new_request` оба равны 1, то в текущем такте завершено выполнение
команды, `id` которой содержится в `unit_wb[0].id`.

==== Блок обращения к памяти

В составе ядра Taiga имеется достаточно развитый блок обращения к памяти,
оснащенный MMU и TLB и имеющий возможность формировать обращение к памяти через
внешние шины. Однако для ясности изложения мы будем рассматривать работу с
локальной синхронной статической памятью без MMU с задержкой доступа в 1 такт (то есть,
данные выдаются в следующем такте, после выставления адреса). Кроме того, рассмотрим
только выполнение команды загрузки.

Итак, в момент планирования на выполнение новой команды (то есть, в момент выставления
сигнала `unit_issue[1].new_request`) происходит формирование на основе сигнала `ls_inputs`
атрибутов транзакции доступа к памяти (адрес, тип, размер и пр.) и их запись в очередь транзакций.

В следующем такте характеристики транзакции становятся доступны на выходе очереди транзакций
(сигнал `/tb/uut/cpu/load_store_unit_block/lsq/transaction_out`), что подтверждается
сигналом `/tb/uut/cpu/load_store_unit_block/lsq/transaction_ready`. Выполняется
дешифрирование адреса и определение вида памяти к которой происходит доступ.
Готовность памяти данных (в нашем случае, готовность памяти имеется всегда, так как время доступа к памяти
всегда составляется 1 такт) дает возможность сформировать запрос к памяти, то есть
выставить на ША адрес, соответствующий характеристикам транзакции.
Адрес формируется комбинационно. Так как блок рассчитан на работу с памятью с неизвестной заранее
задержкой, то характеристики запроса к памяти записываются в очередь запросов к памяти.

В следующем такте память данных выставляет на ШД прочитанные данные (сигнал `/tb/uut/inst_data_ram/data_out_b`) и сигнал готовности
данных `/tb/uut/cpu/load_store_unit_block/bram/data_valid`. Блок фиксирует выполнение команды
выставлением сигнала `unit_wb[1].done` (формируется комбинационно по сигналу `data_valid`),
`unit_wb[1].id` (берется из выхода очереди запросов к памяти) и `unit_wb[1].rd`
(берется с ШД памяти данных).

В этом же такте происходит запись в целевой регистр аналогично тому, как мы это
видели в случае АЛУ.

Таким образом видно, что выполнение команды доступа к памяти занимает минимум 3 такта.

*Заметим*, что несмотря на задержку в 3 такта, блок имеет возможность принимать на выполнение
команды доступа к памяти *каждый* такт. Таким образом, его пропускная способность (*throughput*)
составляет 1 команду/clk, хотя задержка и равна 3 тактам.

.Признак завершения выполнения команды блока доступа к памяти в текущем такте
IMPORTANT: Если в текущем такте сигнал `unit_wb[1].done` равен 1, то в
текущем такте завершено выполнение команды, `id` которой содержится в `unit_wb[1].id`.

==== Блок ветвлений
Блок ветвлений выполняет команды `jal`/`jalr` и команды условного перехода
`bXX`(`XX` - код условия). Данный блок описан в файле `core/branch_unit.sv`.

Начнем рассмотрение его работы с того такта, когда на выполнение запланирована
команда ветвления, то есть, в момент выставления сигнала `unit_issue[2].new_request`.
В этом такте происходит проверка условия ветвления (если оно есть) и на основании
результата проверки, текущего значения `pc` (оно доступно через поле `issue_pc`
структуры `branch_inputs`) и смещения формируется новое значение `pc`.

В начале следующего такта происходит запись сформированного нового значения
`pc`, флага, указывающего на то, что переход выполнен и других сигналов в структуру
`/tb/uut/cpu/branch_unit_block/br_results`. Кроме того, формируется сигнал
`/tb/uut/cpu/branch_unit_block/branch_complete`, указывающий на завершение
выполнения команды, `id` которой выдается через сигнал `/tb/uut/cpu/branch_unit_block/branch_id`.

*Обратим внимание*, что в этом же такте формируется сигнал `/tb/uut/cpu/branch_unit_block/branch_flush`.
Рассмотрим этот сигнал подробнее. На выходе блока декодирования в этом такте
появляется новая команда. Если `pc` этой команды отличается от `br_results.new_pc`,
то есть от адреса, который
был сформирован блоком ветвлений, то устанавливается в 1 сигнал `branch_flush`.
Для понимания процесса, который тут происходит нужно вспомнить, что следующая команда,
которая в этом такте появилась на выходе блока декодирования была выбрана минимум 3 такта назад.
В момент выборки этой команды команда ветвления еще не была выполнена, а значит
адрес перехода (да и сам факт того, что впереди встретится команда парехода)
в общем случае был неизвестен. В таких условиях блок выборки формирует адрес
для выборки следующей команды используя *предсказатель ветвлений* (о нем -- ниже) или
таким образом, как будто следующей будет *выполняться* та команда,
которая *расположена* после текущей. Это верно для всех команд, кроме ветвлений.
Поэтому в блоке ветвлений необходимо обнаруживать ситуацию *ошибочной выборки* и
формировать сигнал `branch_flush`, указывающий то, что последующие команды
были выбраны и декодированы ошибочно, и исполнять их нельзя.

В случае ошибочной выборки (когда `branch_flush=1`) происходят следующие действия:

. блок выборки очищает очередь запросов к памяти, таким образом, в следующем такте сигнал
`fetch_complete` выставлен не будет, а резльтат текущей выборки будет отброшен;
. сигнал `new_pc` в блоке выборки формируется из `br_results.new_pc`, то есть
с использованием адреса, полученного от блока ветвлений;
. блок управления метаинформацией очищает очередь выбранных команд;
. блок декодирования и планирования на выполнение сбрасывает сигналы `unit_issue[i].new_request`,
 запрещая выполнение подготовленной команды.

Если же ошибочной выборки не произошло, то есть, если следующей планируется на исполнение команда,
адрес которой совпадает с адресом перехода, то `branch_flush=0` и никакие дополнительные действия
не выполняются, а высокий уровень сигнала `branch_complete` указывает на то, что
команда с `id` равным `branch_id` завершила выполнение.


.Признак завершения выполнения команды ветвления в текущем такте
IMPORTANT: Если в текущем такте сигнал `branch_complete` равен 1, то в
текущем такте завершено выполнение команды, `id` которой содержится в `branch_id`.

===== Предсказатель ветвлений
Как мы видели из предыдущего раздела ситуация ошибочной выборки крайне негативно сказывается
на производительности, так как приводит к необходимости очистки конвеера, и ожидания
прохождения новой команы по всем стадиям работы. Чтобы этого избежать необходимо уже
на этапе выборки знать адрес следующей команды. Для решения этой задачи используется
блок предсказания ветвлений, описанный в файле `core/branch_predictor.sv`. Подробное
рассмотрение принципа его работы выходит за рамки нашего рассмотрения, отметим лишь,
что в основе его конструкции лежит кеш-память. В эту кеш-память заносятся
сведения об адресах команд переходов и о фактах выполнения/невыполнения этих переходов.
В Taiga используется простой принцип предсказания ветвлений: если при исполнении команды по
некоторому адресу произошел переход, то скорее всего этот переход произойдет и в следующий раз
при исполнении команды с этого адреса.

На вход блока предсказания ветвлений подаются сигналы с выхода блока ветвлений (`br_results`),
содержащих информацию об адресах инструкций ветвлений. Кроме того, на вход блока
предсказания ветвлений подается сигнал `new_pc` блока выборки. В каждом такте
блок предсказания ветвлений формирует сигналы `/tb/uut/cpu/bp/use_prediction` и
`/tb/uut/cpu/bp/predicted_pc`. Если `/tb/uut/cpu/bp/predicted_pc=1`, то ожидается,
что по адресу `new_pc`, сформированном в предыдущем такте, находится команда ветвления,
которое произойдет на адрес `/tb/uut/cpu/bp/predicted_pc`. Блок выборки реагируя
на этой факт в качестве `new_pc` для следующего такта выберет адрес, содержащийся
в `/tb/uut/cpu/bp/predicted_pc`. Таким образом, вслед за выборкой предположительной команды
ветвления произойдет выборка команды, которая будет выполняться после перехода.
Благодаря этому не произойдет ошибочной загрузки и не потребуется очистка
конвеера.

===== Пример выполнения команды условного перехода в случае ошибочного предсказания ветвления
Рассмотрим выполнение команды `bne	x20,x0,8000000c`, расположенной по адресу `0x80000034`, тестового примера
во время выполнения первой итерации цикла.
[[branch_misspredict]]
.Пример выполнения команды безусловного перехода в случае ошибочного предсказания ветвления
image::img/branch_misspredict.png[]

Начнем рассмотрение с такта 25, в котором команда планируется на выполнение. Конфликт отсутствует,
что подтверждается сигналом `unit_issue[2].new_request`, который означает факт планирования
на выполнение в текущем такте (сигналы `rsX_conflict` не приведены на диаграмме для экономии места).

В такте 26 выставляется сигнал `branch_taken`, означающий, что сигнал `br_results.new_pc`
содержит адрес для перехода. В данном такте на выходе блока декодирования появляются
данные следующей выбранной команды, а именно команды, расположенной по адресу `0x80000038`.
Данная команда расположена сразу после команды условного перехода. Во время первой итерации цикла, в момент выборки команды
по адресу `0x80000034` еще не было известно, что это команда условного перехода, и что в данном такте эта команда
выполнится, поэтому блок выборки выбрал в следующем такте команду по адресу `0x80000038`.

В такте 26 обнаруживается несоответствие между адресом `issue.pc=0x80000038` следующей команды и
тем адресом, на который должен быть выполнен переход, а именно `br_results.new_pc=0x8000000c`.
Это является причиной выставления в этом такте сигнала `branch_flush` и сигнала `gc_fetch_flush` который формируется
комбинационно из сигнала `branch_flush`. Появление данного сигнала приводит к очистке конвеера.
Видно, что в такте 26 команда не была запланирована на выполнение (все
сигналы `unit_issue[i].new_request, i=0..2` равны 0). Кроме того, в конце этого такта устанавливается в 0
сигнал `decode.valid`. Сигнал `next_pc` в такте 26 повторяет сигнал `br_results.new_pc`.
Кроме того в данном такте значение сигнала `pc_id_next` приравнивается к значению `decode.id=7` -- идентификатору
последней декодированной команды. Именно такой `id` получит первая команда, выбранная после перехода.

В такте 27 сигнал `pc` становится равным адресу перехода, а сигнал `fetch_complete` сбрасывается в 0,
что означает, что результаты выборки команды по адресу `0x80000050`
(который был завершен в прошлом такте) должен быть отброшен. Команда по новому адресу
проходит стадию выборки в такте 27, диспетчеризации -- в такте 28, декодирования -- в такте 29, и
в такте 30 она планируется для выполнения.

Таким образом, вместо такта 26, в котором следующая команда была бы запланирована на выполнение в идеальном случае,
она была запланирована на выполнение только в такте 30. Потери времени, случившиеся из-за ошибочной выборки составили 4 такта,
что равно длине конвеера.

Обозначим на трассе выполнения данную ситуацию. На фрагменте трассы, приведенном ниже
знаком '*' обозначены те моменты времени, которые не видны на текущей диаграмме.

[cols="3*4m, 18*1m"]
|======================
.2+|Адрес (hex) .2+|Код команды (hex) .2+|Команда          .2+|id 17+|Такты
                                                                     |15 |16  |17 |18 |19 |20 |21 |22 |23 |24 |25 |26 |27 |28 |29 |30 |31
|80000034          |fc0a1ce3             |bne x20,x0,8000000c |5     |F* |ID* |W* |W* |W* |W* |W* |W  |W  |D  |B  |   |   |   |   |   |
|80000038          |001f8f93             |addi x31,x31,1      |6     |   |F*  |ID*|W* |W* |W* |W* |W  |W  |W  |D  |X  |   |   |   |   |
|8000003c          |0000006f             |jal x0,8000003c     |7     |   |    |   |   |F* |ID*|W* |W  |W  |W  |W  |DX |   |   |   |   |
|80000040          |00000001             |<invalid command>   |0     |   |    |   |   |   |F* |ID*|W  |W  |W  |W  |X  |   |   |   |   |
|80000044          |00000002             |<invalid command>   |1     |   |    |   |   |   |   |   |   |F  |ID |W  |X  |   |   |   |   |
|80000048          |00000003             |<invalid command>   |2     |   |    |   |   |   |   |   |   |   |F  |ID |X  |   |   |   |   |
|8000004c          |00000004             |<invalid command>   |3     |   |    |   |   |   |   |   |   |   |   |F  |X  |   |   |   |   |
|80000050          |00000005             |<invalid command>   |4     |   |    |   |   |   |   |   |   |   |   |   |FX |   |   |   |   |
|8000000c<loop>    |0000a103             |lw x2,0(x1)         |2     |   |    |   |   |   |   |   |   |   |   |   |   |F  |ID |D  |M1 |M2*
|======================

Где:
[horizontal]
F :: Такт, в котором происходит операция выборки;
ID :: Такт, в котором происходит операция диспетчеризации;
D  :: Такт, в котором происходит операция декодирования;
С  :: Такт, в котором команда не выполняется из-за конфликта;
W   :: Такт, в котором не происходит декодирования команды из-за загрузки блока декодирования;
X   :: Такт, в котором происходит сброс команд, находящихся в очереди;
DX   :: Такт, в котором декодирование команды происходит, но его результаты отбрасываются;
FX   :: Такт, в котором выборка команды происходит, но его результаты отбрасываются.

===== Пример выполнения команды условного перехода в случае правильного предсказания ветвления
Изменим теперь тестовый пример так, чтобы цикл выполнился 3 раза. Для этого вместо команды
`addi	x20,x0,2` напишем `addi	x20,x0,3`. И рассмотрим выполнение той же команды
`bne	x20,x0,8000000c`, расположенной по адресу `0x80000034`, во время выполнения *второй*
итерации цикла.
[[branch_predict]]
.Пример выполнения команды безусловного перехода в случае правильного предсказания ветвления
image::img/branch_predict.png[]

Из диаграммы видно, что в такте 37 `pc=0x80000034`. В этом такте формируется сигнал `use_prediction`,
указывающий, что сигнал `predicted_pc` содержит значение вероятного адреса следующей команды, а именно
`0x8000000c`. Именно этот адрес записывается в сигнал `next_pc`, а в следующем такте -- в `pc`.
Именно по этому адресу происходит выборка следующей команды в такте 39. Важно отметить, что
пауза в загрузке (сигнал `fetch_complete=0` в такте 38) не связана с ветвлением. Ее причина -- отсутствие свободных мест
в очереди команд, что видно из того факта, что сигнал `pc_id_available` был равен 0 в такте 37. В связи с этим
в такте 37 не могла быть произведена выборка.

В такте 40 происходит диспетчеризация данной команды с `id=2`.

Далее видно, что интересующая нас команда ветвления запланирована на выполнение в такте 48,
сигналы `branch_complete` и `branch_taken` сформированы в такте 49. Однако, в этом же такте планируется
на выполнение команды по адресу `0x8000000c`, которая была выбрана в такте 39. Ее адрес совпадает с
адресом перехода (`br_results.new_pc=0x8000000c`), поэтому сигнал `branch_flush` не формируется,
и следующая команда начинает выполняться уже в такте 49, что подтверждается сигналом `unit_issue[1].new_request`.

Таким образом, правильное предсказание ветвлений существенно повышает производительность.

==== Задание №4

В соответствии с таблицей, приведенной ниже, получить снимок экрана, содержащий
временную диаграмму выполнения стадии выполнения
команды с указанным адресом. Для команд, входящих в тело цикла, приведен номер итерации.

[cols="10*m"]
|======================================
|Вариант                        |1             |2              |3             |4              |5              |6              |7             |8             |9
|Адрес команды, номер итерации  |80000000      |80000004       |80000008      |8000000с, 1-я  |80000010, 1-я  |80000014, 1-я  |80000018, 1-я |8000001с, 1-я |80000020, 1-я
|Вариант                        |10            |11             |12            |13             |14             |15             |16            |17            |18
|Адрес команды, номер итерации  |80000024, 1-я |80000028, 1-я |8000002с, 1-я  |80000030, 1-я  |8000000с, 2-я  |80000010, 2-я  |80000014, 2-я |80000018, 2-я |8000001с, 2-я
|Вариант                        |19            |20             |21            |22             |23             |24             |25            |26            |27
|Адрес команды, номер итерации  |80000020, 2-я |80000024, 2-я  |80000028, 2-я |8000002с, 2-я  |80000030, 2-я  |80000038, 2-я  |См. вариант 1 |См. вариант 2 |См. вариант 3
|======================================



==== Пример трассы выполнения тестовой программы
Продолжая рассуждения, начатые в приведенных выше примерах можно получить полную трассу выполнения программы.
[[trace]]
.Трасса выполнения тестовой программы
image::img/pipeline.svg[]


Где:
[horizontal]
F :: Такт, в котором происходит операция выборки;
ID :: Такт, в котором происходит операция диспетчеризации;
D  :: Такт, в котором происходит операция декодирования;
С  :: Такт, в котором команда не выполняется из-за конфликта;
W   :: Такт, в котором не происходит декодирования команды из-за загрузки блока декодирования;
X   :: Такт, в котором происходит сброс команд, находящихся в очереди;
DX   :: Такт, в котором декодирование команды происходит, но его результаты отбрасываются;
FX   :: Такт, в котором выборка команды происходит, но его результаты отбрасываются;
M1, M2, M3   :: Первый, второй и третий такты, в которых происходит выполнение команды доступа к памяти;
AL   :: Такт, в котором происходит выполнение команды АЛУ;
B    :: Такт, в котором происходит выполнение команды ветвления.

Из рассмотрения трассы видно, что выполнение программы до окончания команды
`addi x31,x31,1` заняло 47 тактов (1-47). Из них, в течение 20 тактов(
7,8, 11, 12, 15, 16, 19, 20, 26-31, 34, 35, 38, 39, 41, 42) не происходило планирование
на выполнение новых команд, то есть, 42% времени было потрачено не эффективно из-за
ошибок предсказания ветвлений и конфликтов на конвейере. Имеется возможность
существенно сократить время выполнения путем перестановки команд для ликвидации конфликтов.

== Задание №5
В процесссе выполнения этого задания необходимо выполнить следующие
действия:

. Исправить файл `taiga/run.sh` или `taiga/run.bat` так, чтобы там был
указан путь к файлу `.hex`, соответствующему программе по индивидуальному варианту. Сохранить файл.
. Закрыть Modelsim.
. Запустить симуляция заново.
. Получить временную диаграмму сигналов выполнения программы индивидуального варианта.
. Сравнить значение регистра `x31` (сигнал `/tb/register_file[31]`) на момент
окончания выполнения программы с тем, который был получен в Задании №1.
. Получить снимок экрана, содержащий временные диаграммы сигналов, соответствующих всем
стадиям выполнения команды, обозначенной в тексте программы символом `#!`.
. Анализируя диаграмму заполнить трассу выполнения программы. Рекомендуется использовать
для этого файл `pipeline.ods`, содержащий трассу тестового примера.
. Сделать вывод об эффективности выполнения программы и о путях оптимизации.
. Провести оптимизацию программы путем перестановки команд для устранения конфликтов.
. Перекомпилировать программу и перезапустить симуляцию.
. Заполнить трассу выполнения оптимизированной программы.
. Сравнить трассы выполнения неоптимизированной и оптимизированной версии, сделать выводы.

== Требования к содержанию отчета
. Титульный лист
. Цели работы, основные теоретические сведения
. Исходный текст исследуемой программы, дизассемблерный листинг, псевдокод,
поясняющий работу программы.
. Скриншоты, полученные в ходе выполнения заданий №2, №3, №4.
. Трассу работы программы (поместить в отчет и приложить к отчету в виде файла-приложения).
. Временные диаграммы (в виде скриншотов окна Modelsim) сигналов, соответствующих всем
стадиям выполнения команды, обозначенной в тексте программы символом `#!`.
. Вывод об эффективности работы программы, предложения по ее оптимизации.
. Исходный текст и дизассемблерный листинг оптимизированной программы.
. Трассу работы оптимизированной программы (поместить в отчет и приложить к отчету в виде приложения).
. Выводы.

== Индивидуальные варианты [[variants]]
.Вариант  1
....
        .section .text
        .globl _start;
        len = 8 #Размер массива
        enroll = 1 #Количество обрабатываемых элементов за одну итерацию
	elem_sz = 4 #Размер одного элемента массива

_start:
        addi x20, x0, len/enroll
        la x1, _x
	add x31, x0, x0
lp:
        lw x2, 0(x1)
        add x31, x31, x2 #!
        addi x1, x1, elem_sz*enroll
        addi x20, x20, -1
        bne x20, x0, lp
        addi x31, x31, 1
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x6
        .4byte 0x7
        .4byte 0x8
....

.Вариант  2
....
        .section .text
        .globl _start;
        len = 8 #Размер массива
        enroll = 1 #Количество обрабатываемых элементов за одну итерацию
	elem_sz = 4 #Размер одного элемента массива

_start:
        addi x20, x0, len/enroll
        la x1, _x
	add x31, x0, x0
lp:
        lw x2, 0(x1)
        addi x1, x1, elem_sz*enroll
        addi x20, x20, -1
        add x31, x31, x2 #!
        bne x20, x0, lp
        addi x31, x31, 1
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x6
        .4byte 0x7
        .4byte 0x8
....

.Вариант  3
....
        .section .text
        .globl _start;
        len = 8 #Размер массива
        enroll = 1 #Количество обрабатываемых элементов за одну итерацию
	elem_sz = 4 #Размер одного элемента массива

_start:
        la x1, _x
        addi x20, x1, elem_sz*(len-1) #Адрес последнего элемента
	add x31, x0, x0
lp:
        lw x2, 0(x1)
        add x31, x31, x2 #!
        addi x1, x1, elem_sz*enroll
        bne x1, x20, lp
        addi x31, x31, 1
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x6
        .4byte 0x7
        .4byte 0x8
....

.Вариант  4
....
        .section .text
        .globl _start;
        len = 8 #Размер массива
        enroll = 1 #Количество обрабатываемых элементов за одну итерацию
	elem_sz = 4 #Размер одного элемента массива

_start:
        la x1, _x
        addi x20, x1, elem_sz*(len-1) #Адрес последнего элемента
	add x31, x0, x0
lp:
        lw x2, 0(x1)
        addi x1, x1, elem_sz*enroll #!
        add x31, x31, x2
        bne x1, x20, lp
        addi x31, x31, 1
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x6
        .4byte 0x7
        .4byte 0x8
....

.Вариант  5
....
        .section .text
        .globl _start;
        len = 8 #Размер массива
        enroll = 2 #Количество обрабатываемых элементов за одну итерацию
	elem_sz = 4 #Размер одного элемента массива

_start:
        addi x20, x0, len/enroll
        la x1, _x
	add x31, x0, x0
lp:
        lw x2, 0(x1)
        add x31, x31, x2
        lw x3, 4(x1)
        add x31, x31, x3 #!
        addi x1, x1, elem_sz*enroll
        addi x20, x20, -1
        bne x20, x0, lp
        addi x31, x31, 1
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x6
        .4byte 0x7
        .4byte 0x8
....

.Вариант  6
....
        .section .text
        .globl _start;
        len = 8 #Размер массива
        enroll = 2 #Количество обрабатываемых элементов за одну итерацию
	elem_sz = 4 #Размер одного элемента массива

_start:
        addi x20, x0, len/enroll
        la x1, _x
	add x31, x0, x0
lp:
        lw x2, 0(x1)
        lw x3, 4(x1) #!
        addi x1, x1, elem_sz*enroll
        addi x20, x20, -1
        add x31, x31, x2
        add x31, x31, x3
        bne x20, x0, lp
        addi x31, x31, 1
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x6
        .4byte 0x7
        .4byte 0x8
....

.Вариант  7
....
        .section .text
        .globl _start;
        len = 8 #Размер массива
        enroll = 2 #Количество обрабатываемых элементов за одну итерацию
	elem_sz = 4 #Размер одного элемента массива

_start:
        la x1, _x
        addi x20, x1, elem_sz*len #Адрес последнего элемента
	add x31, x0, x0
lp:
        lw x2, 0(x1)
        add x31, x31, x2 #!
        lw x3, 4(x1)
        add x31, x31, x3
        addi x1, x1, elem_sz*enroll
        bne x1, x20, lp
        addi x31, x31, 1
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x6
        .4byte 0x7
        .4byte 0x8
....

.Вариант  8
....
        .section .text
        .globl _start;
        len = 8 #Размер массива
        enroll = 2 #Количество обрабатываемых элементов за одну итерацию
	elem_sz = 4 #Размер одного элемента массива

_start:
        la x1, _x
        addi x20, x1, elem_sz*len #Адрес последнего элемента
	add x31, x0, x0
lp:
        lw x2, 0(x1)
        lw x3, 4(x1)
        addi x1, x1, elem_sz*enroll
        add x31, x31, x2 #!
        add x31, x31, x3
        bne x1, x20, lp
        addi x31, x31, 1
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x6
        .4byte 0x7
        .4byte 0x8
....

.Вариант  9
....
        .section .text
        .globl _start;
        len = 8 #Размер массива
        enroll = 4 #Количество обрабатываемых элементов за одну итерацию
	elem_sz = 4 #Размер одного элемента массива

_start:
        addi x20, x0, len/enroll
        la x1, _x
	add x31, x0, x0
lp:
        lw x2, 0(x1)
        add x31, x31, x2 #!
        lw x3, 4(x1)
        add x31, x31, x3
        lw x4, 8(x1)
        lw x5, 12(x1)
        add x31, x31, x4
        add x31, x31, x5
        addi x1, x1, elem_sz*enroll
        addi x20, x20, -1
        bne x20, x0, lp
        addi x31, x31, 1
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x6
        .4byte 0x7
        .4byte 0x8
....

.Вариант  10
....
        .section .text
        .globl _start;
        len = 8 #Размер массива
        enroll = 4 #Количество обрабатываемых элементов за одну итерацию
	elem_sz = 4 #Размер одного элемента массива

_start:
        addi x20, x0, len/enroll
        la x1, _x
	add x31, x0, x0
lp:
        lw x2, 0(x1)
        lw x3, 4(x1) #!
        add x31, x31, x2
        add x31, x31, x3
        lw x4, 8(x1)
        lw x5, 12(x1)
        add x31, x31, x4
        add x31, x31, x5
        addi x1, x1, elem_sz*enroll
        addi x20, x20, -1
        bne x20, x0, lp
        addi x31, x31, 1
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x6
        .4byte 0x7
        .4byte 0x8
....

.Вариант  11
....
        .section .text
        .globl _start;
        len = 8 #Размер массива
        enroll = 4 #Количество обрабатываемых элементов за одну итерацию
	elem_sz = 4 #Размер одного элемента массива

_start:
        la x1, _x
        addi x20, x1, elem_sz*len #Адрес последнего элемента
	add x31, x0, x0
lp:
        lw x2, 0(x1)
        add x31, x31, x2 #!
        lw x3, 4(x1)
        add x31, x31, x3
        lw x4, 8(x1)
        add x31, x31, x4
        lw x5, 12(x1)
        add x31, x31, x5
        addi x1, x1, elem_sz*enroll
        bne x1, x20, lp
        addi x31, x31, 1
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x6
        .4byte 0x7
        .4byte 0x8
....

.Вариант 12
....
        .section .text
        .globl _start;
        len = 8 #Размер массива
        enroll = 4 #Количество обрабатываемых элементов за одну итерацию
	elem_sz = 4 #Размер одного элемента массива

_start:
        la x1, _x
        addi x20, x1, elem_sz*len #Адрес последнего элемента
	add x31, x0, x0
lp:
        lw x2, 0(x1)
        lw x3, 4(x1)
        add x31, x31, x2 #!
        add x31, x31, x3
        lw x4, 8(x1)
        lw x5, 12(x1)
        add x31, x31, x4
        add x31, x31, x5
        addi x1, x1, elem_sz*enroll
        bne x1, x20, lp
        addi x31, x31, 1
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x6
        .4byte 0x7
        .4byte 0x8
....

.Вариант 13
....
        .section .text
        .globl _start;
        len = 9 #Размер массива
        enroll = 1 #Количество обрабатываемых элементов за одну итерацию
        elem_sz = 4 #Размер одного элемента массива

_start:
        la x1, _x
        addi x20, x1, elem_sz*len #Адрес элемента, следующего за последним
        lw x31, 0(x1)
        add x1, x1, elem_sz*1
lp:
        lw x2, 0(x1)
        bltu x2, x31, lt
        add x31, x0, x2 #!
lt:
        add x1, x1, elem_sz*enroll
        bne x1, x20, lp
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x6
        .4byte 0x7
        .4byte 0x8
        .4byte 0x9
....

.Вариант 14
....
        .section .text
        .globl _start;
        len = 9 #Размер массива
        enroll = 1 #Количество обрабатываемых элементов за одну итерацию
        elem_sz = 4 #Размер одного элемента массива

_start:
        la x1, _x
        addi x20, x1, elem_sz*len #Адрес элемента, следующего за последним
        lw x31, 0(x1)
        add x1, x1, elem_sz*1
lp:
        lw x2, 0(x1)
        bltu x2, x31, lt
        add x31, x0, x2 #!
lt:
        add x1, x1, elem_sz*enroll
        bne x1, x20, lp
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x8
        .4byte 0x6
        .4byte 0x7
        .4byte 0x5
        .4byte 0x4
....

.Вариант 15
....
        .section .text
        .globl _start;
        len = 9 #Размер массива
        enroll = 1 #Количество обрабатываемых элементов за одну итерацию
        elem_sz = 4 #Размер одного элемента массива

_start:
        la x1, _x
        addi x20, x0, (len-1)/enroll
        lw x31, 0(x1)
        addi x1, x1, elem_sz*1
lp:
        lw x2, 0(x1)
        bltu x2, x31, lt
        add x31, x0, x2 #!
lt:
        add x1, x1, elem_sz*enroll
        addi x20, x20, -1
        bne x20, x0, lp
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x6
        .4byte 0x7
        .4byte 0x8
        .4byte 0x9
....

.Вариант 16
....
        .section .text
        .globl _start;
        len = 9 #Размер массива
        enroll = 1 #Количество обрабатываемых элементов за одну итерацию
        elem_sz = 4 #Размер одного элемента массива

_start:
        la x1, _x
        addi x20, x0, (len-1)/enroll
        lw x31, 0(x1)
        addi x1, x1, elem_sz*1
lp:
        lw x2, 0(x1)
        add x1, x1, elem_sz*enroll
        bltu x2, x31, lt
        add x31, x0, x2 #!
lt:
        addi x20, x20, -1
        bne x20, x0, lp
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x8
        .4byte 0x6
        .4byte 0x7
        .4byte 0x5
        .4byte 0x4
....

.Вариант 17
....
        .section .text
        .globl _start;
        len = 9 #Размер массива
        enroll = 2 #Количество обрабатываемых элементов за одну итерацию
        elem_sz = 4 #Размер одного элемента массива

_start:
        la x1, _x
        addi x20, x1, elem_sz*len #Адрес элемента, следующего за последним
        lw x31, 0(x1)
        addi x1, x1, elem_sz*1
lp:
        lw x2, 0(x1)
        lw x3, 4(x1) #!
        bltu x2, x31, lt1
        add x31, x0, x2
lt1:    bltu x3, x31, lt2
        add x31, x0, x3
lt2:
        add x1, x1, elem_sz*enroll
        bne x1, x20, lp
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x6
        .4byte 0x7
        .4byte 0x8
        .4byte 0x9
....

.Вариант 18
....
        .section .text
        .globl _start;
        len = 9 #Размер массива
        enroll = 2 #Количество обрабатываемых элементов за одну итерацию
        elem_sz = 4 #Размер одного элемента массива

_start:
        la x1, _x
        addi x20, x1, elem_sz*len #Адрес элемента, следующего за последним
        lw x31, 0(x1)
        addi x1, x1, elem_sz*1
lp:
        lw x2, 0(x1) #!
        lw x3, 4(x1)
        bltu x2, x31, lt1
        add x31, x0, x2
lt1:    bltu x3, x31, lt2
        add x31, x0, x3
lt2:
        add x1, x1, elem_sz*enroll
        bne x1, x20, lp
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x8
        .4byte 0x6
        .4byte 0x7
        .4byte 0x5
        .4byte 0x4
....

.Вариант 19
....
        .section .text
        .globl _start;
        len = 9 #Размер массива
        enroll = 2 #Количество обрабатываемых элементов за одну итерацию
        elem_sz = 4 #Размер одного элемента массива

_start:
        la x1, _x
        addi x20, x0, (len-1)/enroll
        lw x31, 0(x1)
        addi x1, x1, elem_sz*1
lp:
        lw x2, 0(x1)
        lw x3, 4(x1)
        bltu x2, x31, lt1
        add x31, x0, x2 #!
lt1:    bltu x3, x31, lt2
        add x31, x0, x3
lt2:
        add x1, x1, elem_sz*enroll
        addi x20, x20, -1
        bne x20, x0, lp
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x6
        .4byte 0x7
        .4byte 0x8
        .4byte 0x9
....

.Вариант 20
....
        .section .text
        .globl _start;
        len = 9 #Размер массива
        enroll = 2 #Количество обрабатываемых элементов за одну итерацию
        elem_sz = 4 #Размер одного элемента массива

_start:
        la x1, _x
        addi x20, x0, (len-1)/enroll
        lw x31, 0(x1)
        addi x1, x1, elem_sz*1
lp:
        lw x2, 0(x1)
        lw x3, 4(x1)
        add x1, x1, elem_sz*enroll
        bltu x2, x31, lt1
        add x31, x0, x2 #!
lt1:    bltu x3, x31, lt2
        add x31, x0, x3
lt2:
        addi x20, x20, -1
        bne x20, x0, lp
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x8
        .4byte 0x6
        .4byte 0x7
        .4byte 0x5
        .4byte 0x4
....

.Вариант 21
....
        .section .text
        .globl _start;
        len = 8 #Размер массива
        enroll = 4 #Количество обрабатываемых элементов за одну итерацию
        elem_sz = 4 #Размер одного элемента массива

_start:
        la x1, _x
        addi x20, x0, (len-1)/enroll
        lw x31, 0(x1)
        addi x1, x1, elem_sz*1
lp:
        lw x2, 0(x1)
        lw x3, 4(x1)
        lw x4, 8(x1)
        lw x5, 12(x1)
        bltu x2, x31, lt1
        add x31, x0, x2
lt1:    bltu x3, x31, lt2
        add x31, x0, x3
lt2:    bltu x4, x31, lt3
        add x31, x0, x4 #!
lt3:    bltu x5, x31, lt4
        add x31, x0, x5
lt4:
        add x1, x1, elem_sz*enroll
        addi x20, x20, -1
        bne x20, x0, lp
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x6
        .4byte 0x7
        .4byte 0x8
        .4byte 0x9
....

.Вариант 22
....
        .section .text
        .globl _start;
        len = 8 #Размер массива
        enroll = 4 #Количество обрабатываемых элементов за одну итерацию
        elem_sz = 4 #Размер одного элемента массива

_start:
        la x1, _x
        addi x20, x0, (len-1)/enroll
        lw x31, 0(x1)
        addi x1, x1, elem_sz*1
lp:
        lw x2, 0(x1)
        lw x3, 4(x1)
        add x1, x1, elem_sz*enroll
        addi x20, x20, -1
        lw x4, 8(x1)
        lw x5, 12(x1)
        bltu x2, x31, lt1
        add x31, x0, x2
lt1:    bltu x3, x31, lt2
        add x31, x0, x3
lt2:    bltu x4, x31, lt3
        add x31, x0, x4
lt3:    bltu x5, x31, lt4
        add x31, x0, x5  #!
lt4:
        bne x20, x0, lp
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x9
        .4byte 0x5
        .4byte 0x6
        .4byte 0x7
        .4byte 0x8
        .4byte 0x4
....


.Вариант 23
....
        .section .text
        .globl _start;
        len = 9 #Размер массива
        enroll = 4 #Количество обрабатываемых элементов за одну итерацию
        elem_sz = 4 #Размер одного элемента массива

_start:
        la x1, _x
        addi x20, x1, elem_sz*len #Адрес элемента, следующего за последним
        lw x31, 0(x1)
        addi x1, x1, elem_sz*1
lp:
        lw x2, 0(x1)
        lw x3, 4(x1)
        lw x4, 8(x1)
        lw x5, 12(x1)
        bltu x2, x31, lt1
        add x31, x0, x2
lt1:    bltu x3, x31, lt2
        add x31, x0, x3
lt2:    bltu x4, x31, lt3
        add x31, x0, x4 #!
lt3:    bltu x5, x31, lt4
        add x31, x0, x5
lt4:
        add x1, x1, elem_sz*enroll
        bne x20, x1, lp
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x6
        .4byte 0x7
        .4byte 0x8
        .4byte 0x9
....

.Вариант 24
....
        .section .text
        .globl _start;
        len = 9 #Размер массива
        enroll = 4 #Количество обрабатываемых элементов за одну итерацию
        elem_sz = 4 #Размер одного элемента массива

_start:
        la x1, _x
        addi x20, x1, elem_sz*len #Адрес элемента, следующего за последним
        lw x31, 0(x1)
        add x1, x1, elem_sz*1
lp:
        lw x2, 0(x1)
        lw x3, 4(x1)
        add x1, x1, elem_sz*enroll
        lw x4, 8(x1)
        lw x5, 12(x1)
        bltu x2, x31, lt1
        add x31, x0, x2
lt1:    bltu x3, x31, lt2
        add x31, x0, x3
lt2:    bltu x4, x31, lt3
        add x31, x0, x4
lt3:    bltu x5, x31, lt4
        add x31, x0, x5  #!
lt4:
        bne x20, x0, lp
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x9
        .4byte 0x5
        .4byte 0x6
        .4byte 0x7
        .4byte 0x8
        .4byte 0x4
....

.Вариант 25
....
        .section .text
        .globl _start;
        len = 9 #Размер массива
        enroll = 4 #Количество обрабатываемых элементов за одну итерацию
        elem_sz = 4 #Размер одного элемента массива

_start:
        la x1, _x
        addi x20, x1, elem_sz*len #Адрес элемента, следующего за последним
        lw x31, 0(x1)
        add x1, x1, elem_sz*1
lp:
        lw x2, 0(x1)
        lw x3, 4(x1)
        add x1, x1, elem_sz*enroll
        bltu x2, x31, lt1
        add x31, x0, x2
lt1:    bltu x3, x31, lt2
        add x31, x0, x3
lt2:    lw x4, 8(x1) #!
        lw x5, 12(x1)
        bltu x4, x31, lt3
        add x31, x0, x4
lt3:    bltu x5, x31, lt4
        add x31, x0, x5
lt4:
        bne x20, x0, lp
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x9
        .4byte 0x7
        .4byte 0x9
        .4byte 0x4
....

.Вариант 26
....
        .section .text
        .globl _start;
        len = 9 #Размер массива
        enroll = 4 #Количество обрабатываемых элементов за одну итерацию
        elem_sz = 4 #Размер одного элемента массива

_start:
        la x1, _x
        addi x20, x0, (len-1)/enroll
        lw x31, 0(x1)
        addi x1, x1, elem_sz*1
lp:
        lw x2, 0(x1)
        lw x3, 4(x1)
        add x1, x1, elem_sz*enroll
        bltu x2, x31, lt1
        add x31, x0, x2
lt1:    bltu x3, x31, lt2
        add x31, x0, x3
lt2:    lw x4, 8(x1)
        lw x5, 12(x1)
        addi x20, x20, -1 #!
        bltu x4, x31, lt3
        add x31, x0, x4
lt3:    bltu x5, x31, lt4
        add x31, x0, x5
lt4:
        bne x20, x0, lp
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x6
        .4byte 0x9
        .4byte 0x8
        .4byte 0x4
....

.Вариант 27
....
        .section .text
        .globl _start;
        len = 9 #Размер массива
        enroll = 4 #Количество обрабатываемых элементов за одну итерацию
        elem_sz = 4 #Размер одного элемента массива

_start:
        la x1, _x
        addi x20, x0, (len-1)/enroll
        lw x31, 0(x1)
        addi x1, x1, elem_sz*1
lp:
        lw x2, 0(x1)
        lw x3, 4(x1)
        add x1, x1, elem_sz*enroll
        addi x20, x20, -1 #!
        bltu x2, x31, lt1
        add x31, x0, x2
lt1:    bltu x3, x31, lt2
        add x31, x0, x3
lt2:    lw x4, 8(x1)
        lw x5, 12(x1)
        bltu x4, x31, lt3
        add x31, x0, x4
lt3:    bltu x5, x31, lt4
        add x31, x0, x5
lt4:
        bne x20, x0, lp
lp2: j lp2

        .section .data
_x:     .4byte 0x1
        .4byte 0x2
        .4byte 0x3
        .4byte 0x4
        .4byte 0x5
        .4byte 0x6
        .4byte 0x5
        .4byte 0x8
        .4byte 0x9
....
